#include "kernel.h" // Include kernel-specific definitions
#include "common.h" // Include common utility definitions

// External symbols defined elsewhere, here in the linker script
extern char __bss[], __bss_end[], __stack_top[], __free_ram[], __free_ram_end[];

// Function to make an SBI call with given arguments
struct ret_sbi call_sbi(long arg0, long arg1, long arg2, long arg3, long arg4,
                        long arg5, long fid, long eid) {
  // Register assignments for the SBI call
  register long a0 __asm__("a0") = arg0; // First argument placed in a0 register
  register long a1 __asm__("a1") = arg1; // Second argument placed in a1 register
  register long a2 __asm__("a2") = arg2; // Third argument placed in a2 register
  register long a3 __asm__("a3") = arg3; // Fourth argument placed in a3 register
  register long a4 __asm__("a4") = arg4; // Fifth argument placed in a4 register
  register long a5 __asm__("a5") = arg5; // Sixth argument placed in a5 register
  register long a6 __asm__("a6") = fid;  // Function ID placed in a6 register
  register long a7 __asm__("a7") = eid;  // Extension ID placed in a7 register

  // Inline assembly to perform the ecall instruction (triggers the SBI call)
  __asm__ __volatile__("ecall"
                       : "=r"(a0), "=r"(a1)      // Output operands: a0 (error code), a1 (return value)
                       : "r"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5),
                         "r"(a6), "r"(a7)        // Input operands: a0-a7 registers
                       : "memory");              // Clobbered registers: memory might be modified
  return (struct ret_sbi){.err = a0, .val = a1}; // Return the error code and return value
}

// Function to output a character using SBI console output extension
void putchar(char ch) {
  call_sbi(ch, 0, 0, 0, 0, 0, 0, 1); // Call SBI with character in a0, extension ID 1 (console)
}

// A function to allocate pages of memory for a program
paddr_t alloc_pages(uint32_t n) {
  static paddr_t next_paddr = (paddr_t)__free_ram; // Initialize with start of free memory
  paddr_t paddr = next_paddr;                      // Store current allocation point
  next_paddr += n * PAGE_SIZE;                     // Advance the allocation pointer by n pages

  if (next_paddr > (paddr_t)__free_ram_end) {      // Check if we've exceeded available memory
    PANIC("out of memory for execution");          // Trigger kernel panic if out of memory
  }

  memset((void *)paddr, 0, n * PAGE_SIZE);         // Zero out the allocated memory
  return paddr;                                    // Return the physical address of allocated memory
}

// Main function of the kernel
void kernel_main(void) {
  // Clear the BSS section (uninitialized global variables)
  memset(__bss, 0, (size_t)__bss_end - (size_t)__bss);

  paddr_t paddr0 = alloc_pages(5);                 // Allocate 5 pages of memory
  paddr_t paddr1 = alloc_pages(3);                 // Allocate 3 more pages of memory
  printf("alloc_pages test: paddr0=%x\n", paddr0); // Print the address of first allocation
  printf("alloc_pages test: paddr1=%x\n", paddr1); // Print the address of second allocation
  // He the expected difference between the two addresses is 5 * PAGE_SIZE i.e. 5 * 4096 i.e. 5 * 1000 in hexadec,
  // so expected difference is address pointers is 5000
  PANIC("booted");                                 // Trigger kernel panic with "booted" message
}

// Boot function to set up the stack and jump to kernel_main
__attribute__((section(".text.boot")))  // Place in the .text.boot section for early execution
__attribute__((naked))                  // No prologue/epilogue generated by compiler
void boot(void) {
  // Set the stack pointer and jump to kernel_main
  __asm__ __volatile__(
      "mv sp, %[stack_top]\n"                     // Move stack top address to stack pointer register
      "j kernel_main\n"                           // Jump to kernel_main function
      :                                           // No output operands
      : [stack_top] "r"(__stack_top)              // Input operand: stack_top address
  );
}
